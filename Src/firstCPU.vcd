$date
	Wed Nov 28 12:22:00 2018
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module firstCPU $end
$var wire 1 ! zero_EXMEM $end
$var wire 1 " zero $end
$var wire 32 # result_MEMWB [31:0] $end
$var wire 32 $ result_EXMEM [31:0] $end
$var wire 32 % result [31:0] $end
$var wire 32 & readRegister2_IDEX [31:0] $end
$var wire 32 ' readRegister2_EXMEM [31:0] $end
$var wire 32 ( readRegister2 [31:0] $end
$var wire 32 ) readRegister1_IDEX [31:0] $end
$var wire 32 * readRegister1 [31:0] $end
$var wire 32 + readData_MEMWB [31:0] $end
$var wire 32 , op2 [31:0] $end
$var wire 1 - memWrite_EXMEM $end
$var wire 1 . memRead_EXMEM $end
$var wire 32 / instruction_IFID [31:0] $end
$var wire 32 0 instruction [31:0] $end
$var wire 32 1 dataMemory [31:0] $end
$var wire 8 2 controlBits_IDEX [7:0] $end
$var wire 8 3 controlBits [7:0] $end
$var wire 2 4 aluCtrl_IDEX [1:0] $end
$var wire 2 5 aluCtrl [1:0] $end
$var wire 32 6 address_IDEX [31:0] $end
$var wire 32 7 address [31:0] $end
$var reg 1 8 clock $end
$scope module alu $end
$var wire 32 9 op2 [31:0] $end
$var wire 32 : op1 [31:0] $end
$var wire 2 ; aluCtrl [1:0] $end
$var reg 32 < result [31:0] $end
$var reg 1 " zero $end
$upscope $end
$scope module data_memory $end
$var wire 32 = write_data [31:0] $end
$var wire 1 - memWrite $end
$var wire 1 . memRead $end
$var wire 32 > address [31:0] $end
$var reg 32 ? read_data [31:0] $end
$upscope $end
$scope module decode $end
$var wire 5 @ writeRegister [4:0] $end
$var wire 32 A readRegister2 [31:0] $end
$var wire 32 B readRegister1 [31:0] $end
$var wire 32 C instruction [31:0] $end
$var wire 8 D controlBits [7:0] $end
$var wire 2 E aluCtrl [1:0] $end
$var wire 32 F address [31:0] $end
$scope module aluControl $end
$var wire 6 G aluOp [5:0] $end
$var reg 2 H aluCtrl [1:0] $end
$upscope $end
$scope module control $end
$var wire 6 I opcode [5:0] $end
$var reg 1 J aluSrc $end
$var reg 1 K branch $end
$var reg 8 L controlBits [7:0] $end
$var reg 1 M jump $end
$var reg 1 N memRead $end
$var reg 1 O memToReg $end
$var reg 1 P memWrite $end
$var reg 1 Q regDst $end
$var reg 1 R regWrite $end
$upscope $end
$scope module mux $end
$var wire 1 S ctrl $end
$var wire 5 T in1 [4:0] $end
$var wire 5 U in2 [4:0] $end
$var reg 5 V out [4:0] $end
$upscope $end
$scope module readFR1 $end
$var wire 5 W index [4:0] $end
$var reg 32 X value [31:0] $end
$upscope $end
$scope module readFR2 $end
$var wire 5 Y index [4:0] $end
$var reg 32 Z value [31:0] $end
$upscope $end
$scope module writeFR $end
$var wire 1 [ clock $end
$var wire 5 \ index [4:0] $end
$var wire 32 ] value [31:0] $end
$upscope $end
$upscope $end
$scope module ex_mem $end
$var wire 1 8 clock $end
$var wire 1 ^ inMemRead $end
$var wire 1 _ inMemWrite $end
$var wire 32 ` inResult [31:0] $end
$var wire 1 " inZero $end
$var wire 32 a inReadRegister2 [31:0] $end
$var reg 1 . outMemRead $end
$var reg 1 - outMemWrite $end
$var reg 32 b outReadRegister2 [31:0] $end
$var reg 32 c outResult [31:0] $end
$var reg 1 ! outZero $end
$upscope $end
$scope module fetch $end
$var wire 32 d valuePC [31:0] $end
$var wire 32 e instruction [31:0] $end
$var reg 5 f regNumberPC [4:0] $end
$scope module getInstruction $end
$var wire 32 g address [31:0] $end
$var reg 32 h instruction [31:0] $end
$upscope $end
$scope module readPC $end
$var wire 5 i index [4:0] $end
$var reg 32 j value [31:0] $end
$upscope $end
$upscope $end
$scope module id_ex $end
$var wire 1 8 clock $end
$var wire 32 k inAddress [31:0] $end
$var wire 2 l inAluCtrl [1:0] $end
$var wire 8 m inControlBits [7:0] $end
$var wire 32 n inR1 [31:0] $end
$var wire 32 o inR2 [31:0] $end
$var reg 32 p outAddress [31:0] $end
$var reg 2 q outAluCtrl [1:0] $end
$var reg 8 r outControlBits [7:0] $end
$var reg 32 s outR1 [31:0] $end
$var reg 32 t outR2 [31:0] $end
$upscope $end
$scope module if_id $end
$var wire 1 8 clock $end
$var wire 32 u in [31:0] $end
$var reg 32 v out [31:0] $end
$upscope $end
$scope module mem_wb $end
$var wire 1 8 clock $end
$var wire 32 w inReadData [31:0] $end
$var wire 32 x inResult [31:0] $end
$var reg 32 y outReadData [31:0] $end
$var reg 32 z outResult [31:0] $end
$upscope $end
$scope module mux $end
$var wire 1 { ctrl $end
$var wire 32 | in1 [31:0] $end
$var wire 32 } in2 [31:0] $end
$var reg 32 ~ out [31:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx ~
bx }
bx |
x{
bx z
bx y
bx x
bx w
bx v
b101100001000100000000000000000 u
bx t
bx s
bx r
bx q
bx p
bx o
bx n
bx m
bx l
b0xxxxxxxxxxxxxxxx k
b0 j
b0 i
b101100001000100000000000000000 h
b0 g
b0 f
b101100001000100000000000000000 e
b0 d
bx c
bx b
bx a
bx `
x_
x^
b0xxxxx ]
b1 \
z[
bx Z
bx Y
bx X
bx W
bx V
bx U
bx T
xS
xR
xQ
xP
xO
xN
xM
bx L
xK
xJ
bx I
bx H
bx G
b0xxxxxxxxxxxxxxxx F
bx E
bx D
bx C
bx B
bx A
bx @
bx ?
bx >
bx =
bx <
bx ;
bx :
bx 9
08
b0xxxxxxxxxxxxxxxx 7
bx 6
bx 5
bx 4
bx 3
bx 2
bx 1
b101100001000100000000000000000 0
bx /
x.
x-
bx ,
bx +
bx *
bx )
bx (
bx '
bx &
bx %
bx $
bx #
x"
x!
$end
#2
b0 5
b0 E
b0 H
b0 l
b10 ]
b10 @
b10 V
0S
b0 (
b0 A
b0 Z
b0 o
b1 *
b1 B
b1 X
b1 n
b110110 3
b110110 D
b110110 L
b110110 m
0M
1R
1J
0P
1O
1N
0K
0Q
b1011 G
b0 U
b10 T
b10 Y
b1 W
b1011 I
b0 7
b0 F
b0 k
b101100001000100000000000000000 /
b101100001000100000000000000000 C
b101100001000100000000000000000 v
b0xxxxxxxxxxxxxxxx 6
b0xxxxxxxxxxxxxxxx p
b0xxxxxxxxxxxxxxxx }
18
#4
08
#6
b1 %
b1 <
b1 `
b0 ,
b0 9
b0 ~
0"
0_
1^
0{
b110110 2
b110110 r
b0 6
b0 p
b0 }
b0 4
b0 ;
b0 q
b0 &
b0 a
b0 t
b0 |
b1 )
b1 :
b1 s
18
#8
08
#10
b11111111 1
b11111111 ?
b11111111 w
0-
1.
b0 '
b0 =
b0 b
0!
b1 $
b1 >
b1 c
b1 x
18
#12
08
#14
b11111111 +
b11111111 y
b1 #
b1 z
18
#16
08
#18
18
